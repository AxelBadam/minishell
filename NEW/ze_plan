shell functionality
{
	-display prompt
	-working history
	-searh and launch executable (based on PATH variable)
	-handle ' (prevent interpretting metacharacters)
	{
		echo 'What the *heck* is a $ doing here???'
		What the *heck* is a $ doing here???
	}
	-handle " (ignore everything but $)
	{
		echo "Is your home directory $*HOME?"
		Is your home directory /home/barnett?
	}
	-redirections
	-pipes
	{
		pipes has to be setup before entering the execution, 

		if no pipes function
		do builtin
		if there are pipes, fork. 
		int pipe variable in the struct; 
		output and input variable, which are used in pipes and redirections. 
		
	}

	-$
	-$? (exit status of the last foreground pipe)
	-ctrl-C, ctrl-D, ctrl-\
	-builtins
	{
		echo with option -n
		pwd with no options
		export with no options, modifies the enviroment of the process - if I want to modi the parent process' env? just copy the env from the child? 
		-no doubles, update existing VAR=, 
		
		unset with no options, also modifies the env. 
		env with no options or arguments
		cd with only a relative or absolute path, what other paths there is?
		exit with no options
		*********
		only execute parent process if there are no pipes. if there are pipes just dont execute these, think thats what bash does
	}

1. Implement the main loop

	In your main.c file, write a main() function.
	Implement a while loop that displays the prompt, reads input from the user using readline(), and calls a function to handle the input (e.g., handle_input()).

3. Input handling and parsing:

Create a new source file (e.g., input_handling.c) and its corresponding header file (e.g., input_handling.h).
Define a linked list structure (e.g., struct TokenNode) that contains a token (e.g., a char*) and a pointer to the next node.
Implement the handle_input() function to tokenize the input string into commands and arguments.
Write a custom function (e.g., parse_tokens()) that takes the input string and a delimiter (e.g., a space character for arguments or a semicolon for commands) and returns a linked list of tokens.
Use the custom parse_tokens() function to process the input string and identify commands, arguments, I/O redirection, and pipelines.
Free the allocated memory for the linked list nodes after they are no longer needed.
	
4. Working history:

Use add_history() to store commands in the command history.
Use rl_on_new_line(), rl_replace_line(), and rl_redisplay() to manage the display of the command history as the user navigates through it.

5. Search and launch executables:

Implement a function (e.g., launch_executable()) that searches for an executable in the directories specified in the PATH environment variable and launches it using fork() and execve().

7. Handle single quotes (''):

Update the input handling function to treat text within single quotes as a single token, without interpreting any metacharacters.

8. Handle double quotes (""):

Update the input handling function to treat text within double quotes as a single token, interpreting the '$' character for variable substitution but ignoring all other metacharacters.

9. Redirections:

Modify the command execution function to support I/O redirection.
Use open(), close(), dup(), and dup2() to manage file descriptors and redirect standard input and output to the specified files.

10. Pipes:

Modify the command execution function to support command pipelining.
Use pipe(), fork(), and execve() to create processes for each command in the pipeline.
Connect the processes using dup() and dup2() to redirect the output of one command to the input of the next command in the pipeline.

11. Implement $ and $? variables:

Add support for variable substitution using the '$' character.
Implement a function to handle variable substitution within double quotes.
Store the exit status of the last foreground pipe in a variable (e.g., last_exit_status) and make it accessible through the $? variable.

12. Handle ctrl-C, ctrl-D, and ctrl-:

Use signal(), sigaction(), sigemptyset(), and sigaddset() to catch and handle ctrl-C (SIGINT), ctrl-D (EOF), and ctrl-\ (SIGQUIT) signals.

13. Built-in commands:
		echo with option -n
		cd with only a relative or absolute path
		pwd with no options
		export with no options
		unset with no options
		env with no options or arguments
		exit with no options
}

1. Implement the main loop

3. Input handling and parsing with linked list
4. Working history
5. Search and launch executables
6. Interpret special characters (/ and ;)
7. Handle single quotes ('')
8. Handle double quotes ("")
9. Redirections
10. Pipes
11. Implement $ and $? variables
12. Handle ctrl-C, ctrl-D, and ctrl-\
13. Built-in commands


RNOW
-